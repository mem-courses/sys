#import "../../template.typ": *

#show: project.with(
  theme: "lab",
  title: "计算机体系结构 第三次实验报告",
  course: "计算机体系结构",
  semester: "2024-2025 Spring-Summer",
  author: "吴与伦",
  school_id: "3230104585",
  date: "2025-04-21",
  college: "计算机科学与技术学院",
  major: "计算机科学与技术",
  teacher: "陈文智",
)

#lab_header(name: [Lab3: Cache], place: "紫金港 东4-511", date: "2025年4月21日")

== 实验目的和要求

- 理解缓存行的概念
- 理解缓存管理单元（CMU）的原理和 CMU 的状态机
- 掌握缓存管理单元的设计方法
- 掌握缓存行的设计与验证方法

== 实验内容和原理

=== 实验内容

- 设计缓存行和缓存管理单元
- 验证缓存行和缓存管理单元
- 观察仿真波形

=== 实验原理

*缓存(cache)* 是一种高速存储器，位于 CPU 和主存之间，用于存储最近访问的数据和指令。缓存的访问速度远高于主存，可以减少 CPU 访问主存的时间，提高数据访问速度和整体系统性能。

当 CPU 需要访问数据时，首先会检查缓存中是否有该数据(缓存命中)。如果缓存命中，直接从缓存中读取数据，无需访问主存；如果缓存未命中，从主存中读取数据，并将其加载到缓存中，供后续访问。

实验中实现的缓存是 2 路组相联缓存结构。缓存被分为多个 $32$ 个组，其中每个组有 $2$ 个块。另外，每个块需要存储块中的数据、还有 dirty bit、valid bit 和 ref bit。


== 实验过程和数据记录

=== 缓存初始化

回顾一下：我们以 4 个字为一块，2 个块为 1 组，总共 32 个组（64 个块）。

- 第 $i$ 组，第 $0$ 路的标签 $-->$ $i times 2 + 0$ $-->$ `inner_tag[{i, 1'b0}]`。
- 第 $i$ 组，第 $1$ 路的标签 $-->$ $i times 2 + 1$ $-->$ `inner_tag[{i, 1'b1}]`。
- 第 $i$ 组，第 $j$ 路的第 $k$ 个字数据 $-->$ $i times 8 + j times 4 + k$ $-->$ `inner_data[{i, j, k}]`。

据此编写地址解析，还有当前访问地址的所在行的各种 tag 的解析。

=== 时序逻辑设计

对于给定的内存请求，先判断是否缓存命中，以方便执行后续操作。

对于 `load` 指令：

- 如果缓存命中，则从缓存中取出数据，并更新最近有效位。
- 如果缓存未命中，则什么也不做，等待 CPU 给出 `store` 信号以从内存中取出数据。

对于 `store` 指令：

- 如果缓存命中，则应该 `edit` 信号为 $1$，因此编辑缓存中的数据，并且将脏位置为 $1$。
- 如果缓存未命中，则什么也不做，等待 CPU 给出 `store` 信号以从内存中取出数据。

具体实现参见完整代码部分。

=== 完整代码

#codex(read("./src/code/cache.v"), lang: "verilog")

== 实验结果分析


=== 仿真结果

一开始先 store 了一些数据，然后有两次 read 操作。可以发现第一次 miss 了，第二次 hit 了，对应的行的 tags 会有所不同。read hit 的这次操作因为是读到了之前存到的那行，可以发现 ref bit 和 valid bit 都为 $1$。

#align(center, image("images/2025-04-22-12-27-51.png", width: 100%))

后面几次操作是在第 0 组上进行了 LRU 策略的测试，可以发现倒数第二次操作发生了 cache miss，因此（外面的控制单元，这里直接由仿真代码控制）将 line 1 用新的数据重新写入。

#align(center, image("images/2025-04-22-12-28-09.png", width: 100%))

=== 上板测试结果

本实验无需上板测试。

== 讨论与心得

本实验的代码实现还是较为简单的，特别是以填空题的形式给出，提示也比较多。Lab 3 和 Lab 4 可以看成是一体的，把 Lab 3 中的 cache 和 Lab 4 的 cache management unit 结合起来，就是我们传统意义上理解的 cache。
