#import "../../template.typ": *

#show: project.with(
  theme: "lab",
  title: "计算机体系结构 第三次实验报告",
  course: "计算机体系结构",
  semester: "2024-2025 Spring-Summer",
  author: "吴与伦",
  school_id: "3230104585",
  date: "2025-04-21",
  college: "计算机科学与技术学院",
  major: "计算机科学与技术",
  teacher: "陈文智",
)

#lab_header(name: [Lab3: Cache], place: "紫金港 东4-511", date: "2025年4月21日")

== 实验目的和要求

- 理解缓存行的概念
- 理解缓存管理单元（CMU）的原理和 CMU 的状态机
- 掌握缓存管理单元的设计方法
- 掌握缓存行的设计与验证方法

== 实验内容和原理

=== 实验内容

- 设计缓存行和缓存管理单元
- 验证缓存行和缓存管理单元
- 观察仿真波形

=== 实验原理


== 实验过程和数据记录

=== 缓存初始化

回顾一下：我们以 4 个字为一块，2 个块为 1 组，总共 32 个组（64 个块）。

- 第 $i$ 组，第 $0$ 路的标签 $-->$ $i times 2 + 0$ $-->$ `inner_tag[{i, 1'b0}]`。
- 第 $i$ 组，第 $1$ 路的标签 $-->$ $i times 2 + 1$ $-->$ `inner_tag[{i, 1'b1}]`。
- 第 $i$ 组，第 $j$ 路的第 $k$ 个字数据 $-->$ $i times 8 + j times 4 + k$ $-->$ `inner_data[{i, j, k}]`。

=== 时序逻辑设计

对于给定的内存请求，先判断是否缓存命中，以方便执行后续操作。

对于 `load` 指令：

- 如果缓存命中，则从缓存中取出数据，并更新最近有效位。
- 如果缓存未命中，则什么也不做，等待 CPU 给出 `store` 信号以从内存中取出数据。

对于 `store` 指令：

- 如果缓存命中，则应该 `edit` 信号为 $1$，因此编辑缓存中的数据，并且将脏位置为 $1$。
- 如果缓存未命中，则什么也不做，等待 CPU 给出 `store` 信号以从内存中取出数据。

=== 完整代码


== 实验结果分析


=== 仿真结果


=== 上板测试结果


== 讨论与心得

通过这次实验，我熟悉了支持异常和中断的流水线CPU的结构，了解了它是如何实际操作的，以及学会了它的设计方法和程序验证方法，收获颇丰。
值得一提的是，这次实验中，出现了PC跑到后面时，指令变成XXXXXXXX的情况。调试后，发现是读取了错误的rom.hex的问题，于是把读取的相对路径改成了绝对路径（顺带把ram也改了），改完之后，指令便能正确读取了。
